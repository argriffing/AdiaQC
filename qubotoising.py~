'''

File: exponentiation.py
Author: Hadayat Seddiqi
Date: 7.3.12
Description: Test solutions from sapphire.

'''

import optparse
import numpy, scipy, math
from scipy import linalg

# Command line options
if __name__=="__main__":
    parser = optparse.OptionParser("usage: %prog [options] arg1 arg2")
    parser.add_option("-d", "--debug", dest="debug",
                      default="0", type="int",
                      help="debug on or off (0 or 1)")
    parser.add_option("-t", "--time", dest="T", default="10",
                      type="float", help="total run time")
    parser.add_option("-x", "--dt", dest="dt", default="0.1",
                      type="float",help="timestep")
    parser.add_option("-q", "--nqubits", dest="nQubits", default="2",
                      type="int",help="number of qubits")
    (options, args) = parser.parse_args()
    debug = options.debug
    T = options.T
    dt = options.dt
    nQubits = options.nQubits

t = 0.0
i = 0
N = T/dt
Z = numpy.matrix([[1,0],[0,-1]])
X = numpy.matrix([[0,1],[1,0]])
I = numpy.identity(2)
alpha = numpy.zeros((2**nQubits,2**nQubits))
beta = numpy.zeros((2**nQubits,2**nQubits))
delta = numpy.zeros((2**nQubits,2**nQubits))
matrices = []

# Calculate alpha
for i in range(0,nQubits) :
    for m in range(0,nQubits-1) : matrices.append(I)
    matrices.insert(i, Z)
    temp = matrices[0]
    matrices.pop(0)

    while (len(matrices) != 0) :
        temp = numpy.kron(temp, matrices[0])
        matrices.pop(0)

    alpha += temp

temp = 0

# Calculate beta
for i in range(0,nQubits) :
    for j in range(0,nQubits) :
        if (i != j) :
            for m in range(0,nQubits-2) : matrices.append(I)
            matrices.insert(i, Z)
            matrices.insert(j, Z)
            temp = matrices[0]
            matrices.pop(0)

            while (len(matrices) != 0) :
                temp = numpy.kron(temp, matrices[0])
                matrices.pop(0)

            beta += temp

temp = 0

# Calculate delta
for i in range(0,nQubits) :
    for m in range(0,nQubits-1) : matrices.append(I)
    matrices.insert(i, X)
    temp = matrices[0]
    matrices.pop(0)

    while (len(matrices) != 0) :
        temp = numpy.kron(temp, matrices[0])
        matrices.pop(0)

    delta += temp

# Get ground state of initial Hamiltonian (X), set that as initial state
eigval, eigvec = numpy.linalg.eig(delta)
sortperm = eigval.argsort()
eigval = eigval[sortperm]
eigvec = eigvec[:,sortperm]
print (eigvec)
print (delta)
# It's ugly, but we have to cast in order to convert
# 1D row vector into 1D column vector
Psi = numpy.transpose(numpy.matrix(numpy.transpose(eigvec))[0])
print ("Initial state:")
print (Psi)
# Evolve
while (i <= N) :
    if (i != 1) : t0 = t - dt
    else : t0 = 0.0

    H = -1j*(((t**2 - t0**2)/(2*T))*(alpha + beta) + (t - t0 + (t0**2 - t**2)/(2*T))*delta)

    A = linalg.expm(H)
    Psi = A*Psi

    i = i + 1
    t = t + dt

print ("Final state:")
print (Psi)
